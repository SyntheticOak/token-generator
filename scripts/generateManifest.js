import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

const FRAMES_DIR = path.join(__dirname, '../public/assets/frames');
const OUTPUT_FILE = path.join(__dirname, '../src/lib/assetManifest.generated.ts');

// Scan directory structure and generate manifest
function scanFrames(baseDir, category) {
  const frames = [];
  const categoryPath = path.join(baseDir, category);
  
  if (!fs.existsSync(categoryPath)) {
    return frames;
  }

  function scanRecursive(dir, depth = 0, parentCategory = '') {
    const entries = fs.readdirSync(dir, { withFileTypes: true });
    
    for (const entry of entries) {
      if (!entry.isDirectory()) continue;
      
      const fullPath = path.join(dir, entry.name);
      const frameId = entry.name;
      
      // Check if this directory contains frame files (has _1024.png or _mask.png)
      const hasMask = fs.existsSync(path.join(fullPath, `${frameId}_mask.png`));
      const has1024 = fs.existsSync(path.join(fullPath, `${frameId}_1024.png`));
      const has512 = fs.existsSync(path.join(fullPath, `${frameId}_512.png`));
      const has256 = fs.existsSync(path.join(fullPath, `${frameId}_256.png`));
      
      if (hasMask || has1024) {
        // This is a frame directory
        const sizes = [];
        if (has1024) sizes.push(1024);
        if (has512) sizes.push(512);
        if (has256) sizes.push(256);
        
        // Determine categories based on depth and path
        const relativePath = path.relative(categoryPath, dir);
        const pathParts = relativePath === '' ? [] : relativePath.split(path.sep);
        
        let subCategory = pathParts[0] || frameId;
        let subSubCategory = undefined;
        let family = undefined;
        
        // For classes: subCategory = class, subSubCategory = subclass
        if (category === 'classes') {
          subCategory = pathParts[0] || frameId;
          if (pathParts.length > 0) {
            subSubCategory = frameId;
          }
        }
        
        // For races: subCategory = race name, family = race family
        if (category === 'races') {
          if (pathParts.length > 0) {
            family = capitalize(pathParts[0]);
            subCategory = frameId;
          } else {
            subCategory = frameId;
          }
        }
        
        // For world/thematic/seasonal: subCategory = direct parent
        if (['world', 'thematic', 'seasonal'].includes(category)) {
          subCategory = pathParts.length > 0 ? pathParts[pathParts.length - 1] : frameId;
        }
        
        const basePath = `/assets/frames/${category}/${path.relative(categoryPath, fullPath).replace(/\\/g, '/')}`;
        
        const frame = {
          id: frameId,
          name: capitalize(frameId),
          mainCategory: category,
          subCategory,
          ...(subSubCategory && { subSubCategory }),
          ...(family && { family }),
          sizes,
          basePath,
          tags: generateTags(frameId, category, subCategory, subSubCategory, family),
        };
        
        frames.push(frame);
      } else {
        // Continue scanning subdirectories
        scanRecursive(fullPath, depth + 1, entry.name);
      }
    }
  }
  
  scanRecursive(categoryPath);
  return frames;
}

function capitalize(str) {
  return str.charAt(0).toUpperCase() + str.slice(1);
}

function generateTags(id, mainCategory, subCategory, subSubCategory, family) {
  const tags = [id];
  
  if (mainCategory === 'classes') {
    tags.push('class', subCategory);
    if (subSubCategory) tags.push(subSubCategory);
  } else if (mainCategory === 'races') {
    tags.push('race', subCategory);
    if (family) tags.push(family.toLowerCase());
  } else {
    tags.push(mainCategory, subCategory);
  }
  
  return tags;
}

function generateManifest() {
  console.log('Generating asset manifest...');
  
  const allFrames = [];
  const categories = ['classes', 'races', 'world', 'thematic', 'seasonal'];
  
  for (const category of categories) {
    const frames = scanFrames(FRAMES_DIR, category);
    allFrames.push(...frames);
    console.log(`  Found ${frames.length} frames in ${category}`);
  }
  
  console.log(`Total frames: ${allFrames.length}`);
  
  // Generate TypeScript file
  const output = `// AUTO-GENERATED FILE - DO NOT EDIT
// Generated by scripts/generateManifest.js
// Run 'npm run build' to regenerate

import { AssetRecord } from "../types";

export const assets: AssetRecord = {
  frames: ${JSON.stringify(allFrames, null, 2)},
};
`;
  
  fs.writeFileSync(OUTPUT_FILE, output, 'utf8');
  console.log(`Manifest written to ${path.relative(process.cwd(), OUTPUT_FILE)}`);
}

generateManifest();


